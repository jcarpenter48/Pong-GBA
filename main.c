#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/background.h"
#include "images/bottomline.h"
#include "images/topline.h"
#include "images/midline.h"
#include "images/ball.h"
#include "images/blankball.h"
#include "images/paddle1.h"
#include "images/paddle2.h"
#include "images/blankpaddle.h"
#include "images/start.h"

#include "images/win.h"
#include "images/lose.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START, //0
  START_NODRAW, //1
  PLAY_INIT, //2
  PLAY, //3
  WIN, //4
  LOSE, //5
  WIN_NODRAW, //6
  LOSE_NODRAW, //7  
};

//initialize an array for storing each side's score values
int score[] = {0, 0};
//initialize our elements
pball pongball;
paddle paddleA;
paddle paddleB;
int gameCounter = 1;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  //gameState cState; //ended up not being necessary
    //cState.currentState = 0; //START
  paddleA.xPos = 0;
  paddleB.xPos = WIDTH - 10;
  
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        waitForVBlank();
        drawFullScreenImageDMA(start);
        // state = ?
        state = START_NODRAW; //go static start screen awaiting button input after drawing
        break;
      case START_NODRAW:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            state = PLAY_INIT;
        } //if player hits start, away we go
        break;
      case PLAY_INIT:
        score[0] = 0;
        score[1] = 0;
        waitForVBlank();
        initializePlay();
        // state = ?
        state = PLAY;
        break;
      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
            break;
        } //if player hits select, back to home    
        waitForVBlank();
            //update our score counter
            char buffer[51];
            sprintf(buffer, "%d", score[0]);
            drawRectDMA(88, 9, 20, 10, BLACK);
            drawString(10, 90, buffer, WHITE);
            sprintf(buffer, "%d", score[1]);
            drawRectDMA(139, 9, 20, 10, BLACK);
            drawString(10, 140, buffer, WHITE);
            drawImageDMA(116, 6, 3, 147, midline);
        //ball movement
            moveBall();
        //ai paddle
            aiPaddle();
            drawImageDMA(0, 155, 240, 5, bottomline);
            drawImageDMA(0, 1, 240, 4, topline);
        //controls
        if(KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
                drawImageDMA(0, paddleA.yPos, 10, 34, blankpaddle);
                paddleA.yPos++;
                drawImageDMA(0, paddleA.yPos, 10, 34, paddle1);            
        }
        if(KEY_HELD(BUTTON_DOWN, currentButtons, previousButtons) && paddleA.yPos < 120) {
            drawImageDMA(0, paddleA.yPos, 10, 34, blankpaddle);
            paddleA.yPos+=2;
            drawImageDMA(0, paddleA.yPos, 10, 34, paddle1);  
        }
        if(KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
                drawImageDMA(0, paddleA.yPos, 10, 34, blankpaddle);
                paddleA.yPos--;
                drawImageDMA(0, paddleA.yPos, 10, 34, paddle1);            
        }
        if(KEY_HELD(BUTTON_UP, currentButtons, previousButtons) && paddleA.yPos > 5) {
            drawImageDMA(0, paddleA.yPos, 10, 34, blankpaddle);
            paddleA.yPos-=2;
            drawImageDMA(0, paddleA.yPos, 10, 34, paddle1);  
        }        
        
        //score listeners
        if (score[0] >= 10) {
            state = WIN;
            break;
        }
        if (score[1] >= 10) {
            state = LOSE;
            break;
        }
        //default next state is continue playing
        state = PLAY;
        break;
      case WIN:
        waitForVBlank();
        drawFullScreenImageDMA(win);
        // state = ?
        state = WIN_NODRAW;
        break;
      case LOSE:
        waitForVBlank();
        drawFullScreenImageDMA(lose);
        // state = ?
        state = LOSE_NODRAW;
        break;
      case WIN_NODRAW:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            state = PLAY_INIT;
        } //if player hits start, play again
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        } //if player hits select, back to title    
        // state = ?
        break;
      case LOSE_NODRAW:
        // state = ?
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            state = PLAY_INIT;
        } //if player hits start, try again
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        } //if player hits select, back to title          
        break;        
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  //UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}

int checkCollision(pball theball, paddle thepaddle) {  
	int left_a, left_b;
	int right_a, right_b;
	int top_a, top_b;
	int bottom_a, bottom_b;

	left_a = theball.xPos + 2;
	right_a = theball.xPos + 8;
	top_a = theball.yPos;
	bottom_a = theball.yPos + 8;

	left_b = thepaddle.xPos - 1;
	right_b = thepaddle.xPos + 12;
	top_b = thepaddle.yPos + 1;
	bottom_b = thepaddle.yPos + 34;
	

	if (left_a > right_b) {
		return 0;
	}

	if (right_a < left_b) {
		return 0;
	}

	if (top_a > bottom_b) {
		return 0;
	}

	if (bottom_a < top_b) {
		return 0;
	}

	return 1;    
}

void moveBall(void) {
    //waitForVBlank();
    /*move ball according to vector*/
    drawImageDMA(pongball.xPos, pongball.yPos, 8, 8, blankball);
    pongball.xPos += pongball.dx;
    pongball.yPos += pongball.dy;
    drawImageDMA(pongball.xPos, pongball.yPos, 8, 8, ball);  
    /*turn ball around if it hits edge of screen*/
    if (pongball.xPos < 0) {
        score[1]++;
        gameCounter++;
        waitForVBlank();
        initializePlay();
        return;
    }
    if (pongball.xPos > WIDTH - 8) {
        score[0]++;
        gameCounter++;
        waitForVBlank();
        initializePlay();
        return;
    }
    if (pongball.yPos < 10 || pongball.yPos > HEIGHT - 15) {
        pongball.dy = -pongball.dy;
    }
    
	//check for collision with the paddle
	int i;

    int c = checkCollision(pongball, paddleB);
	for (i = 0; i < 2; i++) { 
		//collision detected	
		if (c == 1) {
			
			//ball moving left
			if (pongball.dx < 0) {
                if (pongball.dx > -10) {
                    pongball.dx -= 1;
                }
			//ball moving right
			} else {
                if (pongball.dx < 10) {
                    pongball.dx += 1;
                }
			}
			
			//change ball direction
			pongball.dx = -pongball.dx;
			
			//change ball angle based on where on the paddle it hit
			int collPos = (paddleB.yPos + 34) - pongball.yPos;

			if (collPos >= 0 && collPos < 7) {
				pongball.dy = 4;
			}

			if (collPos >= 7 && collPos < 14) {
				pongball.dy = 3;
			}
			
			if (collPos >= 14 && collPos < 21) {
				pongball.dy = 2;
			}

			if (collPos >= 21 && collPos < 28) {
				pongball.dy = 1;
			}

			if (collPos >= 28 && collPos < 32) {
				pongball.dy = 0;
			}

			if (collPos >= 32 && collPos < 39) {
				pongball.dy = -1;
			}

			if (collPos >= 39 && collPos < 46) {
				pongball.dy = -2;
			}

			if (collPos >= 46 && collPos < 53) {
				pongball.dy = -3;
			}

			if (collPos >= 53 && collPos <= 60) {
				pongball.dy = -4;
			}
		}
        c = checkCollision(pongball, paddleA);
	}
    return;
}
void initializePlay(void) {
        waitForVBlank();
        drawFullScreenImageDMA(background);
        pongball.xPos = WIDTH / 2;
        pongball.yPos = HEIGHT / 2;
        drawImageDMA(pongball.xPos, pongball.yPos, 8, 8, ball);
        if ((gameCounter & 1) == 0) {
            pongball.dx = 1;
        } else {
            pongball.dx = -1;
        }
        pongball.dy = -1;
        
        //paddleA.xPos = 20;
        paddleA.yPos = (HEIGHT / 2);
        drawImageDMA(0, paddleA.yPos, 10, 34, paddle1);
        //paddleB.xPos = WIDTH - 20 - 10;
        paddleB.yPos = (HEIGHT / 2) + 10;
        drawImageDMA(WIDTH - 10, paddleB.yPos, 10, 34, paddle2); 
        
        //draw our score counters
        char buffer[51];
			sprintf(buffer, "%d", score[0]);
            drawRectDMA(88, 9, 10, 10, BLACK);
        drawString(10, 90, buffer, WHITE);
            sprintf(buffer, "%d", score[1]);
            drawRectDMA(139, 9, 10, 10, BLACK);
        drawString(10, 140, buffer, WHITE);
}

void aiPaddle(void) {
	int center = paddleB.yPos + 17;
	int screenCenter = 80;    
	int ballSpeed = pongball.dy;

	if (ballSpeed < 0) {
		ballSpeed = -ballSpeed;
	}
    drawImageDMA(WIDTH - 10, paddleB.yPos, 10, 34, blankpaddle);
	//ball moving left
	if (pongball.dx < 0) {
		
		//return to center position
		if (center < screenCenter) {
                paddleB.yPos += 2;
		
		} else {
                paddleB.yPos -= 2;	
		}

	//ball moving right
	} else {
	
		//ball moving down
		if (pongball.dy > 0) { 
			if (pongball.yPos > center) { 
                    paddleB.yPos += ballSpeed;
			} else { 
                if (paddleB.yPos > 5) {
                    paddleB.yPos -= ballSpeed;
                } else {
                    paddleB.yPos -= 0;
                }
			}
		}
		
		//ball moving up
		if (pongball.dy < 0) {
			if (pongball.yPos < center) { 
                if (paddleB.yPos > 5) {
                    paddleB.yPos -= ballSpeed;
                } else {
                    paddleB.yPos -= 0;
                }
			} else {
                    paddleB.yPos += ballSpeed;
			}
		}	 		
	}    
    drawImageDMA(WIDTH - 10, paddleB.yPos, 10, 34, paddle2);      
}
